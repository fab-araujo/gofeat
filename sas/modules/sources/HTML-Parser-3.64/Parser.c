/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.35 from the
 * contents of Parser.xs. Do not edit this file, edit Parser.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Parser.xs"
/* 
 * Copyright 1999-2009, Gisle Aas.
 * Copyright 1999-2000, Michael A. Chase.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the same terms as Perl itself.
 */


/*
 * Standard XS greeting.
 */
#ifdef __cplusplus
extern "C" {
#endif
#define PERL_NO_GET_CONTEXT     /* we want efficiency */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef __cplusplus
}
#endif



/*
 * Some perl version compatibility gruff.
 */
#include "patchlevel.h"
#if PATCHLEVEL <= 4 /* perl5.004_XX */

#ifndef PL_sv_undef
   #define PL_sv_undef sv_undef
   #define PL_sv_yes   sv_yes
#endif

#ifndef PL_hexdigit
   #define PL_hexdigit hexdigit
#endif

#ifndef ERRSV
   #define ERRSV GvSV(errgv)
#endif

#if (PATCHLEVEL == 4 && SUBVERSION <= 4)
/* The newSVpvn function was introduced in perl5.004_05 */
static SV *
newSVpvn(char *s, STRLEN len)
{
    register SV *sv = newSV(0);
    sv_setpvn(sv,s,len);
    return sv;
}
#endif /* not perl5.004_05 */
#endif /* perl5.004_XX */

#ifndef dNOOP
   #define dNOOP extern int errno
#endif
#ifndef dTHX
   #define dTHX dNOOP
   #define pTHX_
   #define aTHX_
#endif

#ifndef MEMBER_TO_FPTR
   #define MEMBER_TO_FPTR(x) (x)
#endif

#ifndef INT2PTR
   #define INT2PTR(any,d)  (any)(d)
   #define PTR2IV(p)       (IV)(p)
#endif


#if PATCHLEVEL > 6 || (PATCHLEVEL == 6 && SUBVERSION > 0)
   #define RETHROW	   croak(Nullch)
#else
   #define RETHROW    { STRLEN my_na; croak("%s", SvPV(ERRSV, my_na)); }
#endif

#if PATCHLEVEL < 8
   /* No useable Unicode support */
   /* Make these harmless if present */
   #undef SvUTF8
   #undef SvUTF8_on
   #undef SvUTF8_off
   #define SvUTF8(sv)      0
   #define SvUTF8_on(sv)   0
   #define SvUTF8_off(sv)  0
#else
   #define UNICODE_HTML_PARSER
#endif

#ifdef G_WARN_ON
   #define DOWARN (PL_dowarn & G_WARN_ON)
#else
   #define DOWARN PL_dowarn
#endif

#ifndef CLONEf_JOIN_IN
   #define CLONEf_JOIN_IN 0
#endif

/*
 * Include stuff.  We include .c files instead of linking them,
 * so that they don't have to pollute the external dll name space.
 */

#ifdef EXTERN
  #undef EXTERN
#endif

#define EXTERN static /* Don't pollute */

#include "hparser.h"
#include "util.c"
#include "hparser.c"


/*
 * Support functions for the XS glue
 */

static SV*
check_handler(pTHX_ SV* h)
{
    if (SvROK(h)) {
	SV* myref = SvRV(h);
	if (SvTYPE(myref) == SVt_PVCV)
	    return newSVsv(h);
	if (SvTYPE(myref) == SVt_PVAV)
	    return SvREFCNT_inc(myref);
	croak("Only code or array references allowed as handler");
    }
    return SvOK(h) ? newSVsv(h) : 0;
}


static PSTATE*
get_pstate_iv(pTHX_ SV* sv)
{
    PSTATE *p;
#if PATCHLEVEL < 8
    p = INT2PTR(PSTATE*, SvIV(sv));
#else
    MAGIC *mg = SvMAGICAL(sv) ? mg_find(sv, '~') : NULL;

    if (!mg)
	croak("Lost parser state magic");
    p = (PSTATE *)mg->mg_ptr;
    if (!p)
	croak("Lost parser state magic");
#endif
    if (p->signature != P_SIGNATURE)
	croak("Bad signature in parser state object at %p", p);
    return p;
}


static PSTATE*
get_pstate_hv(pTHX_ SV* sv)                               /* used by XS typemap */
{
    HV* hv;
    SV** svp;

    sv = SvRV(sv);
    if (!sv || SvTYPE(sv) != SVt_PVHV)
	croak("Not a reference to a hash");
    hv = (HV*)sv;
    svp = hv_fetch(hv, "_hparser_xs_state", 17, 0);
    if (svp) {
	if (SvROK(*svp))
	    return get_pstate_iv(aTHX_ SvRV(*svp));
	else
	    croak("_hparser_xs_state element is not a reference");
    }
    croak("Can't find '_hparser_xs_state' element in HTML::Parser hash");
    return 0;
}


static void
free_pstate(pTHX_ PSTATE* pstate)
{
    int i;
    SvREFCNT_dec(pstate->buf);
    SvREFCNT_dec(pstate->pend_text);
    SvREFCNT_dec(pstate->skipped_text);
#ifdef MARKED_SECTION
    SvREFCNT_dec(pstate->ms_stack);
#endif
    SvREFCNT_dec(pstate->bool_attr_val);
    for (i = 0; i < EVENT_COUNT; i++) {
	SvREFCNT_dec(pstate->handlers[i].cb);
	SvREFCNT_dec(pstate->handlers[i].argspec);
    }

    SvREFCNT_dec(pstate->report_tags);
    SvREFCNT_dec(pstate->ignore_tags);
    SvREFCNT_dec(pstate->ignore_elements);
    SvREFCNT_dec(pstate->ignoring_element);

    SvREFCNT_dec(pstate->tmp);

    pstate->signature = 0;
    Safefree(pstate);
}

static int
magic_free_pstate(pTHX_ SV *sv, MAGIC *mg)
{
#if PATCHLEVEL < 8
    free_pstate(aTHX_ get_pstate_iv(aTHX_ sv));
#else
    free_pstate(aTHX_ (PSTATE *)mg->mg_ptr);
#endif
    return 0;
}

#if defined(USE_ITHREADS) && PATCHLEVEL >= 8

static PSTATE *
dup_pstate(pTHX_ PSTATE *pstate, CLONE_PARAMS *params)
{
    PSTATE *pstate2;
    int i;

    Newz(56, pstate2, 1, PSTATE);
    pstate2->signature = pstate->signature;

    pstate2->buf = SvREFCNT_inc(sv_dup(pstate->buf, params));
    pstate2->offset = pstate->offset;
    pstate2->line = pstate->line;
    pstate2->column = pstate->column;
    pstate2->start_document = pstate->start_document;
    pstate2->parsing = pstate->parsing;
    pstate2->eof = pstate->eof;

    pstate2->literal_mode = pstate->literal_mode;
    pstate2->is_cdata = pstate->is_cdata;
    pstate2->no_dash_dash_comment_end = pstate->no_dash_dash_comment_end;
    pstate2->pending_end_tag = pstate->pending_end_tag;

    pstate2->pend_text = SvREFCNT_inc(sv_dup(pstate->pend_text, params));
    pstate2->pend_text_is_cdata = pstate->pend_text_is_cdata;
    pstate2->pend_text_offset = pstate->pend_text_offset;
    pstate2->pend_text_line = pstate->pend_text_offset;
    pstate2->pend_text_column = pstate->pend_text_column;

    pstate2->skipped_text = SvREFCNT_inc(sv_dup(pstate->skipped_text, params));

#ifdef MARKED_SECTION
    pstate2->ms = pstate->ms;
    pstate2->ms_stack =
	(AV *)SvREFCNT_inc(sv_dup((SV *)pstate->ms_stack, params));
    pstate2->marked_sections = pstate->marked_sections;
#endif

    pstate2->strict_comment = pstate->strict_comment;
    pstate2->strict_names = pstate->strict_names;
    pstate2->strict_end = pstate->strict_end;
    pstate2->xml_mode = pstate->xml_mode;
    pstate2->unbroken_text = pstate->unbroken_text;
    pstate2->attr_encoded = pstate->attr_encoded;
    pstate2->case_sensitive = pstate->case_sensitive;
    pstate2->closing_plaintext = pstate->closing_plaintext;
    pstate2->utf8_mode = pstate->utf8_mode;
    pstate2->empty_element_tags = pstate->empty_element_tags;
    pstate2->xml_pic = pstate->xml_pic;
    pstate2->backquote = pstate->backquote;

    pstate2->bool_attr_val =
	SvREFCNT_inc(sv_dup(pstate->bool_attr_val, params));
    for (i = 0; i < EVENT_COUNT; i++) {
	pstate2->handlers[i].cb =
	    SvREFCNT_inc(sv_dup(pstate->handlers[i].cb, params));
	pstate2->handlers[i].argspec =
	    SvREFCNT_inc(sv_dup(pstate->handlers[i].argspec, params));
    }
    pstate2->argspec_entity_decode = pstate->argspec_entity_decode;

    pstate2->report_tags =
	(HV *)SvREFCNT_inc(sv_dup((SV *)pstate->report_tags, params));
    pstate2->ignore_tags =
	(HV *)SvREFCNT_inc(sv_dup((SV *)pstate->ignore_tags, params));
    pstate2->ignore_elements =
	(HV *)SvREFCNT_inc(sv_dup((SV *)pstate->ignore_elements, params));

    pstate2->ignoring_element =
	SvREFCNT_inc(sv_dup(pstate->ignoring_element, params));
    pstate2->ignore_depth = pstate->ignore_depth;

    if (params->flags & CLONEf_JOIN_IN) {
	pstate2->entity2char =
	    perl_get_hv("HTML::Entities::entity2char", TRUE);
    } else {
	pstate2->entity2char = (HV *)sv_dup((SV *)pstate->entity2char, params);
    }
    pstate2->tmp = SvREFCNT_inc(sv_dup(pstate->tmp, params));

    return pstate2;
}

static int
magic_dup_pstate(pTHX_ MAGIC *mg, CLONE_PARAMS *params)
{
    mg->mg_ptr = (char *)dup_pstate(aTHX_ (PSTATE *)mg->mg_ptr, params);
    return 0;
}

#endif

MGVTBL vtbl_pstate =
{
    0,
    0,
    0,
    0,
    MEMBER_TO_FPTR(magic_free_pstate),
#if defined(USE_ITHREADS) && PATCHLEVEL >= 8
    0,
    MEMBER_TO_FPTR(magic_dup_pstate),
#endif
};


/*
 *  XS interface definition.
 */

#line 342 "Parser.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 486 "Parser.c"

XS_EUPXS(XS_HTML__Parser__alloc_pstate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Parser__alloc_pstate)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV*	self = ST(0)
;
#line 340 "Parser.xs"
	PSTATE* pstate;
	SV* sv;
	HV* hv;
        MAGIC* mg;

#line 503 "Parser.c"
#line 346 "Parser.xs"
	sv = SvRV(self);
        if (!sv || SvTYPE(sv) != SVt_PVHV)
            croak("Not a reference to a hash");
	hv = (HV*)sv;

	Newz(56, pstate, 1, PSTATE);
	pstate->signature = P_SIGNATURE;
	pstate->entity2char = perl_get_hv("HTML::Entities::entity2char", TRUE);
	pstate->tmp = NEWSV(0, 20);

	sv = newSViv(PTR2IV(pstate));
#if PATCHLEVEL < 8
	sv_magic(sv, 0, '~', 0, 0);
#else
	sv_magic(sv, 0, '~', (char *)pstate, 0);
#endif
	mg = mg_find(sv, '~');
        assert(mg);
        mg->mg_virtual = &vtbl_pstate;
#if defined(USE_ITHREADS) && PATCHLEVEL >= 8
        mg->mg_flags |= MGf_DUP;
#endif
	SvREADONLY_on(sv);

	hv_store(hv, "_hparser_xs_state", 17, newRV_noinc(sv), 0);
#line 530 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_HTML__Parser_parse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Parser_parse)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, chunk");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	self = ST(0)
;
	SV*	chunk = ST(1)
;
#line 377 "Parser.xs"
	PSTATE* p_state = get_pstate_hv(aTHX_ self);
#line 551 "Parser.c"
#line 379 "Parser.xs"
	if (p_state->parsing)
    	    croak("Parse loop not allowed");
        p_state->parsing = 1;
	if (SvROK(chunk) && SvTYPE(SvRV(chunk)) == SVt_PVCV) {
	    SV* generator = chunk;
	    STRLEN len;
	    do {
                int count;
		PUSHMARK(SP);
	        count = perl_call_sv(generator, G_SCALAR|G_EVAL);
		SPAGAIN;
		chunk = count ? POPs : 0;
	        PUTBACK;

	        if (SvTRUE(ERRSV)) {
		    p_state->parsing = 0;
		    p_state->eof = 0;
		    RETHROW;
                }

		if (chunk && SvOK(chunk)) {
		    (void)SvPV(chunk, len);  /* get length */
		}
		else {
		    len = 0;
                }
		parse(aTHX_ p_state, len ? chunk : 0, self);
	        SPAGAIN;

            } while (len && !p_state->eof);
        }
	else {
	    parse(aTHX_ p_state, chunk, self);
            SPAGAIN;
        }
        p_state->parsing = 0;
	if (p_state->eof) {
	    p_state->eof = 0;
            PUSHs(sv_newmortal());
        }
	else {
	    PUSHs(self);
	}
#line 596 "Parser.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_HTML__Parser_eof); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Parser_eof)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	self = ST(0)
;
#line 427 "Parser.xs"
	PSTATE* p_state = get_pstate_hv(aTHX_ self);
#line 616 "Parser.c"
#line 429 "Parser.xs"
        if (p_state->parsing)
            p_state->eof = 1;
        else {
	    p_state->parsing = 1;
	    parse(aTHX_ p_state, 0, self); /* flush */
	    p_state->parsing = 0;
	}
	PUSHs(self);
#line 626 "Parser.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_HTML__Parser_strict_comment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Parser_strict_comment)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "pstate, ...");
    {
	PSTATE*	pstate = get_pstate_hv(aTHX_ ST(0))
;
#line 456 "Parser.xs"
	bool *attr;
#line 645 "Parser.c"
	SV *	RETVAL;
#line 458 "Parser.xs"
        switch (ix) {
	case  1: attr = &pstate->strict_comment;       break;
	case  2: attr = &pstate->strict_names;         break;
	case  3: attr = &pstate->xml_mode;             break;
	case  4: attr = &pstate->unbroken_text;        break;
        case  5:
#ifdef MARKED_SECTION
		 attr = &pstate->marked_sections;      break;
#else
	         croak("marked sections not supported"); break;
#endif
	case  6: attr = &pstate->attr_encoded;         break;
	case  7: attr = &pstate->case_sensitive;       break;
	case  8: attr = &pstate->strict_end;           break;
	case  9: attr = &pstate->closing_plaintext;    break;
#ifdef UNICODE_HTML_PARSER
        case 10: attr = &pstate->utf8_mode;            break;
#else
	case 10: croak("The utf8_mode does not work with this perl; perl-5.8 or better required");
#endif
	case 11: attr = &pstate->empty_element_tags;   break;
        case 12: attr = &pstate->xml_pic;              break;
	case 13: attr = &pstate->backquote;            break;
	default:
	    croak("Unknown boolean attribute (%d)", ix);
        }
	RETVAL = boolSV(*attr);
	if (items > 1)
	    *attr = SvTRUE(ST(1));
#line 677 "Parser.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HTML__Parser_boolean_attribute_value); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Parser_boolean_attribute_value)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "pstate, ...");
    {
	PSTATE*	pstate = get_pstate_hv(aTHX_ ST(0))
;
	SV *	RETVAL;
#line 494 "Parser.xs"
	RETVAL = pstate->bool_attr_val ? newSVsv(pstate->bool_attr_val)
				       : &PL_sv_undef;
	if (items > 1) {
	    SvREFCNT_dec(pstate->bool_attr_val);
	    pstate->bool_attr_val = newSVsv(ST(1));
        }
#line 702 "Parser.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HTML__Parser_ignore_tags); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Parser_ignore_tags)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "pstate, ...");
    {
	PSTATE*	pstate = get_pstate_hv(aTHX_ ST(0))
;
#line 511 "Parser.xs"
	HV** attr;
	int i;
#line 723 "Parser.c"
#line 514 "Parser.xs"
	switch (ix) {
	case  1: attr = &pstate->report_tags;     break;
	case  2: attr = &pstate->ignore_tags;     break;
	case  3: attr = &pstate->ignore_elements; break;
	default:
	    croak("Unknown tag-list attribute (%d)", ix);
	}
	if (GIMME_V != G_VOID)
	    croak("Can't report tag lists yet");

	items--;  /* pstate */
	if (items) {
	    if (*attr)
		hv_clear(*attr);
	    else
		*attr = newHV();

	    for (i = 0; i < items; i++) {
		SV* sv = ST(i+1);
		if (SvROK(sv)) {
		    sv = SvRV(sv);
		    if (SvTYPE(sv) == SVt_PVAV) {
			AV* av = (AV*)sv;
			STRLEN j;
			STRLEN len = av_len(av) + 1;
			for (j = 0; j < len; j++) {
			    SV**svp = av_fetch(av, j, 0);
			    if (svp) {
				hv_store_ent(*attr, *svp, newSViv(0), 0);
			    }
			}
		    }
		    else
			croak("Tag list must be plain scalars and arrays");
		}
		else {
		    hv_store_ent(*attr, sv, newSViv(0), 0);
		}
	    }
	}
	else if (*attr) {
	    SvREFCNT_dec(*attr);
            *attr = 0;
	}
#line 769 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_HTML__Parser_handler); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Parser_handler)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "pstate, eventname, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	PSTATE*	pstate = get_pstate_hv(aTHX_ ST(0))
;
	SV*	eventname = ST(1)
;
#line 564 "Parser.xs"
	STRLEN name_len;
	char *name = SvPV(eventname, name_len);
        int event = -1;
        int i;
        struct p_handler *h;
#line 794 "Parser.c"
#line 570 "Parser.xs"
	/* map event name string to event_id */
	for (i = 0; i < EVENT_COUNT; i++) {
	    if (strEQ(name, event_id_str[i])) {
	        event = i;
	        break;
	    }
	}
        if (event < 0)
	    croak("No handler for %s events", name);

	h = &pstate->handlers[event];

	/* set up return value */
	if (h->cb) {
	    PUSHs((SvTYPE(h->cb) == SVt_PVAV)
	                 ? sv_2mortal(newRV_inc(h->cb))
	                 : sv_2mortal(newSVsv(h->cb)));
	}
        else {
	    PUSHs(&PL_sv_undef);
        }

        /* update */
        if (items > 3) {
	    SvREFCNT_dec(h->argspec);
	    h->argspec = 0;
	    h->argspec = argspec_compile(ST(3), pstate);
	}
        if (items > 2) {
	    SvREFCNT_dec(h->cb);
            h->cb = 0;
	    h->cb = check_handler(aTHX_ ST(2));
	}
#line 829 "Parser.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_HTML__Entities_decode_entities); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Entities_decode_entities)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 610 "Parser.xs"
        int i;
	HV *entity2char = perl_get_hv("HTML::Entities::entity2char", FALSE);
#line 847 "Parser.c"
#line 613 "Parser.xs"
	if (GIMME_V == G_SCALAR && items > 1)
            items = 1;
	for (i = 0; i < items; i++) {
	    if (GIMME_V != G_VOID)
	        ST(i) = sv_2mortal(newSVsv(ST(i)));
	    else if (SvREADONLY(ST(i)))
		croak("Can't inline decode readonly string");
	    decode_entities(aTHX_ ST(i), entity2char, 0);
	}
	SP += items;
#line 859 "Parser.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_HTML__Entities__decode_entities); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Entities__decode_entities)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "string, entities, ...");
    {
	SV*	string = ST(0)
;
	SV*	entities = ST(1)
;
#line 629 "Parser.xs"
	HV* entities_hv;
        bool expand_prefix = (items > 2) ? SvTRUE(ST(2)) : 0;
#line 880 "Parser.c"
#line 632 "Parser.xs"
        if (SvOK(entities)) {
	    if (SvROK(entities) && SvTYPE(SvRV(entities)) == SVt_PVHV) {
		entities_hv = (HV*)SvRV(entities);
	    }
            else {
		croak("2nd argument must be hash reference");
            }
        }
        else {
            entities_hv = 0;
        }
	if (SvREADONLY(string))
	    croak("Can't inline decode readonly string");
	decode_entities(aTHX_ string, entities_hv, expand_prefix);
#line 896 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_HTML__Entities__probably_utf8_chunk); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Entities__probably_utf8_chunk)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "string");
    {
	SV*	string = ST(0)
;
#line 651 "Parser.xs"
        STRLEN len;
        char *s;
#line 914 "Parser.c"
	bool	RETVAL;
#line 654 "Parser.xs"
#ifdef UNICODE_HTML_PARSER
        sv_utf8_downgrade(string, 0);
	s = SvPV(string, len);
        RETVAL = probably_utf8_chunk(aTHX_ s, len);
#else
        RETVAL = 0; /* avoid never initialized complains from compiler */
	croak("_probably_utf8_chunk() only works for Unicode enabled perls");
#endif
#line 925 "Parser.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HTML__Entities_UNICODE_SUPPORT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HTML__Entities_UNICODE_SUPPORT)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 669 "Parser.xs"
#ifdef UNICODE_HTML_PARSER
       RETVAL = 1;
#else
       RETVAL = 0;
#endif
#line 947 "Parser.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_HTML__Parser); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_HTML__Parser)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("HTML::Parser::_alloc_pstate", XS_HTML__Parser__alloc_pstate);
        newXS_deffile("HTML::Parser::parse", XS_HTML__Parser_parse);
        newXS_deffile("HTML::Parser::eof", XS_HTML__Parser_eof);
        cv = newXS_deffile("HTML::Parser::attr_encoded", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 6;
        cv = newXS_deffile("HTML::Parser::backquote", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 13;
        cv = newXS_deffile("HTML::Parser::case_sensitive", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 7;
        cv = newXS_deffile("HTML::Parser::closing_plaintext", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 9;
        cv = newXS_deffile("HTML::Parser::empty_element_tags", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 11;
        cv = newXS_deffile("HTML::Parser::marked_sections", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 5;
        cv = newXS_deffile("HTML::Parser::strict_comment", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("HTML::Parser::strict_end", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 8;
        cv = newXS_deffile("HTML::Parser::strict_names", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 2;
        cv = newXS_deffile("HTML::Parser::unbroken_text", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 4;
        cv = newXS_deffile("HTML::Parser::utf8_mode", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 10;
        cv = newXS_deffile("HTML::Parser::xml_mode", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 3;
        cv = newXS_deffile("HTML::Parser::xml_pic", XS_HTML__Parser_strict_comment);
        XSANY.any_i32 = 12;
        newXS_deffile("HTML::Parser::boolean_attribute_value", XS_HTML__Parser_boolean_attribute_value);
        cv = newXS_deffile("HTML::Parser::ignore_elements", XS_HTML__Parser_ignore_tags);
        XSANY.any_i32 = 3;
        cv = newXS_deffile("HTML::Parser::ignore_tags", XS_HTML__Parser_ignore_tags);
        XSANY.any_i32 = 2;
        cv = newXS_deffile("HTML::Parser::report_tags", XS_HTML__Parser_ignore_tags);
        XSANY.any_i32 = 1;
        newXS_deffile("HTML::Parser::handler", XS_HTML__Parser_handler);
        newXS_deffile("HTML::Entities::decode_entities", XS_HTML__Entities_decode_entities);
        newXS_deffile("HTML::Entities::_decode_entities", XS_HTML__Entities__decode_entities);
        newXS_deffile("HTML::Entities::_probably_utf8_chunk", XS_HTML__Entities__probably_utf8_chunk);
        (void)newXSproto_portable("HTML::Entities::UNICODE_SUPPORT", XS_HTML__Entities_UNICODE_SUPPORT, file, "");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

